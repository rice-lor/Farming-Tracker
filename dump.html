<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Inventory Dump with Trigger</title>
</head>
<body>
    <!-- UI is intentionally left blank as per the request. -->
    <script>
    (() => {
        // --- CONFIGURATION & CONSTANTS ---
        const DUMP_TRIGGER_CONFIG = {
            triggerKey: "inventorydump", // Hardcoded trigger key
            displayName: "Inventory Dump" // Hardcoded display name
        };
        
        // Menu action text from the original script
        const OPEN_STORAGE_ACTION = "Open Storage";
        const PUT_ALL_ACTION = "Put All";
        
        // Timing constants from the original script for reliable execution
        const NUI_TIMEOUT = 10;
        const NUI_RETRIES = 300;
        const NUI_SUBMIT_TIMEOUT = 5;
        const NUI_SUBMIT_RETRIES = 200;
        const NUI_EXTRA_DELAY = 10;
        
        // --- CACHE ---
        // Stores data from the parent application (game client)
        const cache = {};

        // --- CORE LOGIC ---

        /**
         * A simple delay function.
         * @param {number} ms - Milliseconds to wait.
         * @returns {Promise<void>}
         */
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        /**
         * Waits until a specific condition is met, with a timeout.
         * @param {function(): boolean} conditionFn - Function that returns true when the condition is met.
         * @param {number} retries - Number of times to check.
         * @param {number} timeout - Delay between checks.
         * @param {string} [errorMessage=null] - Error to throw on failure.
         * @returns {Promise<boolean>}
         */
        function waitUntil(conditionFn, retries, timeout, errorMessage = null) {
            return new Promise(async (resolve, reject) => {
                while (conditionFn() === false) {
                    if (retries-- <= 0) return reject(new Error(errorMessage || "WaitUntil timed out."));
                    await sleep(timeout);
                }
                await sleep(NUI_EXTRA_DELAY);
                resolve(true);
            });
        }

        /**
         * Sends a menu choice command and waits for the menu state to change.
         * @param {string} choice - The full menu option text to select (including HTML).
         * @param {number} [mod=0] - The modification (-1 for left, 0 for enter, 1 for right).
         */
        async function forceMenuChoice(choice, mod = 0) {
            const initialMenuState = {
                menu: cache.menu,
                menu_open: cache.menu_open,
                prompt: cache.prompt,
                menu_choices: JSON.stringify(cache.menu_choices)
            };

            window.parent.postMessage({
                type: "forceMenuChoice",
                choice: choice,
                mod: mod
            }, "*");
            
            try {
                // Wait for any change in the menu state
                await waitUntil(() => 
                    initialMenuState.menu !== cache.menu || 
                    initialMenuState.menu_open !== cache.menu_open || 
                    initialMenuState.prompt !== cache.prompt || 
                    initialMenuState.menu_choices !== JSON.stringify(cache.menu_choices), 
                    NUI_SUBMIT_RETRIES, 
                    NUI_SUBMIT_TIMEOUT
                );
            } catch {
                // If the wait times out, we continue anyway as some actions don't change the menu.
            }
        }

        /**
         * Executes a sequence of actions on the in-game menu.
         * @param {object[]} actionSequence - The list of actions to perform.
         */
        async function executeActions(actionSequence) {
            try {
                for (const step of actionSequence) {
                    for (const action of step.actions) {
                        // Sanitize action text by removing HTML tags for comparison
                        const cleanActionText = action.action.replace(/(<.+?>)|(&#.+?;)/g, "");
                        
                        await waitUntil(
                            () => cache.menu_open && (cache.menu_choices ?? []).some(c => c && c[0].replace(/(<.+?>)|(&#.+?;)/g, "") === cleanActionText),
                            NUI_RETRIES,
                            NUI_TIMEOUT,
                            `Could not find option '${cleanActionText}' in menu.`
                        );

                        // Find the full menu choice text (with HTML tags) to send back
                        const choiceWithTags = cache.menu_choices.find(c => c[0].replace(/(<.+?>)|(&#.+?;)/g, "") === cleanActionText)[0];
                        await forceMenuChoice(choiceWithTags, action.mod);
                    }
                }
            } catch (error) {
                // Send an in-game notification if any step fails.
                window.parent.postMessage({ type: "notification", text: error.message }, "*");
            }
        }

        /**
         * Creates the specific action sequence for dumping the inventory.
         * @returns {object[]}
         */
        function createInventoryDumpActions() {
            return [{
                actions: [{
                    action: OPEN_STORAGE_ACTION,
                    mod: 0
                }, {
                    action: PUT_ALL_ACTION,
                    mod: 0
                }],
                amount: 0 // Amount is not needed for this simple sequence
            }];
        }
        
        /**
         * Listens for messages from the parent application.
         */
        window.addEventListener("message", (event) => {
            if (!event.data) return;

            // Handle data updates to populate the cache.
            if (event.data.data) {
                for (const [key, value] of Object.entries(event.data.data)) {
                    if (key === 'menu' || key === 'menu_open' || key === 'prompt') {
                         cache[key] = value;
                    }
                    // The menu_choices are sent as a stringified JSON array.
                    if (key === 'menu_choices') {
                        try {
                             cache[key] = JSON.parse(value ?? "[]");
                        } catch {
                            cache[key] = [];
                        }
                    }
                }
            }

            // Handle the trigger action.
            if (event.data.trigger === DUMP_TRIGGER_CONFIG.triggerKey) {
                const dumpSequence = createInventoryDumpActions();
                executeActions(dumpSequence);
            }
        });

        /**
         * This script runs when the document is loaded.
         */
        document.addEventListener("DOMContentLoaded", function() {
            // Register the custom trigger with the parent.
            window.parent.postMessage({
                type: "registerTrigger",
                trigger: DUMP_TRIGGER_CONFIG.triggerKey,
                name: DUMP_TRIGGER_CONFIG.displayName
            }, "*");
            
            // Request the initial data needed for menu interaction.
            window.parent.postMessage({
                type: "getNamedData",
                keys: ["menu", "menu_choices", "menu_open", "prompt"]
            }, "*");
        });
    })();
    </script>
</body>
</html>

